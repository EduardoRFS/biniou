An extensible serialization format.

Main features:

* Robust to changes: record fields and variants can be removed or added
  without necessarily requiring consumer or producer upgrade.  Unknown
  record fields may be ignored by a reader.  Missing record fields can
  receive a default value.

* Fast: vector-like structures are preceded by a header indicating
  their length.

* Low-level: does not specify a type system other than the core
  containers



Format:

VAL ::= ATOM
      | ARRAY
      | TUPLE
      | RECORD
      | NUM_VARIANT
      | VARIANT
      | TUPLE_TABLE
      | RECORD_TABLE
      | MATRIX

ATOM ::= int8
       | int16
       | int32
       | int64
       | int128
       | float64
       | uvint    // unsigned vint
       | svint    // signed vint
       | string

BOXVAL ::= TAG VAL

ARRAY ::= LENGTH (TAG VAL*)?
NUM_VARIANT ::= NUM_VARIANT_TAG BOXVAL?
VARIANT ::= VARIANT_TAG BOXVAL?
TUPLE ::= LENGTH BOXVAL*
RECORD ::= LENGTH (FIELD_TAG BOXVAL)*
TUPLE_TABLE ::= LENGTH (LENGTH TAG* (VAL*)*)?               // list of tuples
RECORD_TABLE ::= LENGTH (LENGTH (FIELD_TAG TAG)* (VAL*)*)?  // list of records
MATRIX ::= LENGTH (LENGTH TAG (VAL*)*)?          // rectangular 2D array

TAG ::= int8
LENGTH ::= uvint
NUM_VARIANT_TAG ::= int8    // 0-127 if no argument, 128-255 if has argument
VARIANT_TAG ::= int32       // first bit indicates argument, then 31-bit hash
FIELD_TAG ::= int32         // 31-bit hash


Byte order is big-endian.

Values for TAG:
int8: 1
int16: 2
int32: 3
int64: 4
int128: 5
float64: 12
uvint: 16
svint: 17
string : 18
array: 19
tuple: 20
record: 21
numeric variant: 22
variant: 23
tuple table: 24
record_table: 25
matrix: 26

Variant and field tags are stored using 4 bytes.
The first bit is 0 for variants without an argument, and 1 for
variants with an argument or record fields.
The remaining 31 bits are obtained by hashing the name of the variant
or field as follows:

hash(s):
  h <- 0
  for i = 0 to length(s) - 1 do
    h <- 223 * h + s[i]
  done
  h <- h mod 2^31
  return h
